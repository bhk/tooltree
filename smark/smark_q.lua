-- smark_q : test smark.lua or smark executable file
--
-- By default, this loads and calls 'smark.lua' directly, but it will test
-- a compiled executable form of smark if given a "smark=<exe>" argument.
--
-- For debugging, use env vars:
--   smark_q='a b'         =>  run tests a & b only
--   smark_q=-V            =>  verbose mode
--   smark_q='-V a b'      =>  verbose mode & run a & b only
--
-- Look at <tmp>/smarklog to see p4x's interaction with simp4
--
-- Command-line arguments:
--    smark=<exe> : executable to test (optional)
--    simp4=<exe>  : simp4 command [alternative: $SIMP4 ]
--    tmp=<tmpdir> : temp dir to use; defaults to $OUTDIR
--    v=1          : verbose [alternative: $smark_q_v ]
--
-- Environment vars:
--    smark_q_v     = verbose mode (if set)
--    smark_q_tests = list of tests to run (run all if unset)
--    SIMP4         = simp4 command
--    OUTDIR        = temp dir default
--

local qt = require "qtest"
local xpfs = require "xpfs"
local fu = require "lfsu"
local TE = require "testexe"
local getopts = require "getopts"

local eq, match = qt.eq, qt.match


----------------------------------------------------------------
-- Utilities
----------------------------------------------------------------

-- Reset FS state: create files listed in files[] and delete all others
-- under current directory (except for files starting with ".").
--
local function initFS(files, top)
   for _,f in ipairs(xpfs.dir(top or ".")) do
      if f:sub(1,1) ~= "." then
         fu.rm_rf(f)
      end
   end

   for k,v in pairs(files or {}) do
      assert(fu.mkdir_p( (fu.splitpath(k)) ))
      -- write file unless we are just creating the directory
      if not k:match("/%.$") then
         local ro, data = v:match("(%%?)(.*)")
         assert(fu.write(k, data))
         if ro == "%" then
            xpfs.chmod(k, "-w")
         end
      end
   end
end


----------------------------------------------------------------
-- Initialization
----------------------------------------------------------------

-- Process command arguments

local names, opts = getopts.read({...}, {"--cmd/-C=","--tmp=" })
local opts = os.getenv("smark_q") or ""
local bVerbose = opts:upper():match("[^%s]+") == "-V"

-- Specify command to execute

local e = TE:new( opts.cmd or "@smark.lua", bVerbose)

e.bTee = bVerbose
local function smark(str)
   local ignoreError, args = str:match("(!?)(.*)")
   e:exec(args)
   if ignoreError == "" then
      if type(e.retval) == "number" and e.retval ~= 0 then
         error("command returned error: "..e.retval, 2)
      end
   else
      local err = e.out .. e.stderr
      if err:match("stack traceback") then
         error("Uncaught exception:\n" .. err, 2)
      end
   end
end

-- Initialize work directory & 'cd' there
--
-- Note: due to changing directories, we need a LUA_PATH that consists of
-- absolute paths, as well as arguments (like --cmd) that are asbolute.
require "lpeg"

local startdir = xpfs.getcwd()
local workdir = assert(os.getenv("OUTDIR")) .. "/TESTEXE"

if bVerbose then print("workdir = "..workdir) end

fu.rm_rf(workdir)
xpfs.mkdir(workdir)
assert(xpfs.chdir(workdir))

----------------------------------------------------------------
-- Tests
----------------------------------------------------------------

function qt.tests.cmdErrors()
   initFS {
      ["a.css"] = "/* a.css */",
      ["x.txt"] = "x.txt",
   }
   smark "!x.txt -o x.html -css=a.css"
   match(e.stderr, "[Uu]nrecognized option")

   smark "!doesnotexist.txt -o x.html"
   match(e.stderr, "Could not find file")

   smark "!x.txt -o x.html --css=doesnotexist.css"
   match(e.stderr, "Could not read file")
end


function qt.tests.css()
   local files = {
      ["a.css"] = "/* A.CSS */",
      ["b.css"] = "/* B.CSS */",
      ["x.txt"] = "This is a test"
   }
   initFS(files)
   smark "x.txt -o x.html --css=a.css --css=b.css"
   match((fu.read("x.html")), "A%.CSS.-B%.CSS")
end


function qt.tests.config()
   local files = {
      ["a.cfg"] = 'abc = 7+35',
      ["x.txt"] = '.lua: print(doc.config.abc)'
   }
   initFS(files)
   smark "x.txt -o x.html --config=a.cfg"
   e:expect("^42\n$")
end


function qt.tests.utf8()
   -- bug: certain invalid UTF8 byte sequences in input triggered uncaught error
   -- bug: any invalid UTF8 generated by script triggered uncaught error
   initFS {
      ["x.txt"] = string.char(224)..string.char(128)..string.char(128),
      ["y.txt"] = ".lua: string.char(224)"
   }
   smark "x.txt -o x.html"

   smark "y.txt -o y.html"
end


function qt.tests.deps()
   local files = {
      ["a.css"] = 'a { color: blue; }',
      ["a.txt"] = 'before\n\n.include: b.txt\n\nafter',
      ["b.txt"] = 'hello',
   }
   initFS(files)
   smark "a.txt -o a.html --css=a.css --no-default-css --deps=a.d"
   e:expect("^$")

   match((fu.read("a.html")), "hello")
   match((fu.read("a.d")), "a.html: b.txt a.css\n\nb.txt:\n\na.css:\n\n")
end


function qt.tests.error()
   -- >> With `--error`, warnings should result in non-zero status code.

   local files = {
      ["a.txt"] = "`unterminated\n"
   }
   initFS(files)

   smark "!a.txt -o a.html --error"
   qt.eq(e.retval, 1)
   match(e.stderr, "Warnings treated as errors")
end


----------------------------------------------------------------

return qt.runTests()

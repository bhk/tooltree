#----------------------------------------------------------------
# Crank generator classes for building C/C++ and linking executables.
#----------------------------------------------------------------

# configuration

# typically defined in a V-specific wrapper (e.g. .crank/release/crank-c.min)
crank-c.dir := $(<dirname>)
crank-c.rungcov := $(crank-c.dir)/rungcov.sh

crank-c.ctools ?=
crank-c.cdep ?=
crank-c.ccov ?= $(if $(crank-c.ctools),$(crank-c.ctools)/)ccov
crank-c.cmet ?= $(if $(crank-c.ctools),$(crank-c.ctools)/)cmet
crank-c.gcov ?= gcov
crank-c.toolchain ?= $(or $(call v.,c-toolchain),c-toolchain_NOT_DEFINED)
crank-c.targetOS ?=
crank-c.coverage ?=

# Include toolchain
$(call <require>,crank-c-$(crank-c.toolchain).min)


#----------------------------------------------------------------
# InferCC : Base class that builds intermediate object files.
#
# For each file in `.ccIn` that contains a C or C++ file, InferCC uses the
# Compile class (with the source file as the item name) to generate rules.
# In order to customize these intermediate instances, project makefiles can
# specify `Compile.<property>` or `Compile[filename].<property>`.
#
# InferCC's outputs are:
#    .^ = object files: those listed in ccIn and those compiled
#         from sources listed in ccIn
#    .inferredItems = a list of inferred build items
#
# InferCC's inputs are:
#   .ccPats : Make patterns matching source files (all other inputs are
#             assumed to be object files or libraries)
#   .ccIn : sources and object files
#   .in : sources and object files
#
# All inputs are given default values (see below).

InferCC.^             = $(foreach i,$(call .,ccIn),$(if $(filter $(call .,ccPats),$i),$(call get,out,$(call .,inferClass),$i),$i))
InferCC.objectFiles   = $(filter %.o %.obj,$(call .,^))
InferCC.inferredItems = $(call .,inferredObjs)
InferCC.inferredObjs  = $(patsubst %,$(call .,inferClass)[%],$(filter $(call .,ccPats),$(call .,ccIn)))
InferCC.inferClass    = Compile
InferCC.ccPats        = %.c %.cpp %.cc %.cxx
InferCC.ccIn          = $(call .,in)
InferCC.in            = $(wildcard $(subst %,*,$(call .,ccPats)))
InferCC.link++        = $(filter %.cpp %.cc %.cxx,$(call .,ccIn))


#----------------------------------------------------------------
# Compile: Compile C or C++ to object
#
# crank-c leaves this class (and others) empty so Makefiles can treat it as
# a derived class.  When they assign properties they can use `$(call
# inherit)` to obtain the default behavior.
#
# Generic flags (compiler-independent):
#
#   warn:      request high level of compiler warnings
#   error:     cause build to fail if any warnings are omitted
#   opt:       optimize code
#   protect:   generate stack guard code
#   includes:  add directories listed in `.includes` to search path
#
# Append "noXXX" to disable a flag previously listed in flags.

Compile.parent = Compile-$(crank-c.toolchain) CompileBase Options Gen

# inherit .flags from Options (which pulls in V-specific options)
CompileBase.flags = warn error opt protect includes $(call inherit)

#----------------------------------------------------------------
# Exe: Generate an executable from object files or sources

Exe.parent = InferCC Exe-$(crank-c.toolchain) ExeBase Options Gen

ExeBase.flags = protect $(call inherit)

#----------------------------------------------------------------
# Lib: Generate a static library from object files of sources

Lib.parent = InferCC Lib-$(crank-c.toolchain) Options Gen

LibBase.flags = $(call inherit)

#----------------------------------------------------------------
# SharedLib: Generate a shared library from object files of sources

# `.dlib` is the shared/dynamic library itself.
# `.out` *may* contain more than one file file (.implib on Windows)
SharedLibBase.dlib   = $(firstword $(call .,out))
SharedLibBase.implib =

SharedLib.parent = InferCC SharedLib-$(crank-c.toolchain) SharedLibBase Options Gen

SharedLibBase.flags = $(call inherit)

#----------------------------------------------------------------
# ExeTest: Build and run a program as a unit test.
#
# Each test program is expected to exit with a 0 status code.
# Use Exe[$I].<property> to influence Exe properties.

ExeTest.parent   = ExeCoverage Test
ExeTest.test     = $(call .,runCov) $(call v.,c-emulator) $(call .,exe) $(call .,args)
ExeTest.exe      = $(call get,out,$(call .,exeClass),$I)
ExeTest.exeClass = Exe
ExeTest.inferredItems = $(call .,exeClass)[$I]


#----------------------------------------------------------------
# ExeCoverage: mixin for test classes.
#
# This defines `runCov`, which is a command prefix for the test command. For
# non-coverage builds, this is an empty string.
#
# In coverage builds, if the test succeeds, it writes an output file
# (`.covOut`) that describes the coverage data generated by that
# command. Some derived classes/items may issue additional test commands
# after running the executable, so we distinguish `.out` from `.covOut`.

ExeCoverage.runCov =

ifneq "$(crank-c.coverage)" ""


ExeCoverage.ext = .cov
ExeCoverage.covOut = $(call .,out).tmp
ExeCoverage.runCov = $(crank-c.rungcov) -o$(call .,covOut) -g$(crank-c.gcov) -c$(crank-c.ccov) $(addprefix -O,$(call .,covObjects))
ExeCoverage.touch = $(\n)cp $(call .,covOut) $(call .,out)

# Collect object files that compose inferred items. ExeTest infers Exe
# items, but subclasses of ExeTest might use classes other than Exe.
ExeCoverage.covObjects = $(call <itemGet>,objectFiles,$(call .,inferredItems))


CompileBase.flags   += coverage
ExeBase.flags       += coverage
SharedLibBase.flags += coverage


# Coverage[<source>] outputs gcov-style listing for <source>.#
#
# NOTE: this describes only the coverage from the test classes listed in
# `.classes`.

Coverage.parent = Gen
Coverage.command = $(crank-c.ccov) -o $@ --list=$I $(call .,options) $(call .,deps)
Coverage.ext = .gcov
Coverage.classes = ExeTest
Coverage.deps = $(call get*,out,$(call .,classes))
Coverage.valueDeps = #
Coverage.options = #

# CoverageMetrics
Phony += CoverageMetrics
Phony[CoverageMetrics].deps = $(call get*,out,$(Coverage.classes))
Phony[CoverageMetrics].command = $(crank-c.ccov) $(call .,deps) -ocsv $(call .,csv) && $(crank-c.cmet) $(call .,csv)
Phony[CoverageMetrics].csv = $(call v.,buildDir)/metrics


endif

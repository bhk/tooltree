# Minion builder classes for working with JS sources
#
#    JSBundle, JSToHMTL: bundle a JS file with its dependencies
#    JSTest: run tests on JS files
#
# Imported variables:
#    

# BuildJS: mixin that describes external dependencies of this makefile.
#
BuildJS.inherit = _BuildJS
_BuildJS.jsdepExe := $(dir $(lastword $(MAKEFILE_LIST)))jsdep
_BuildJS.node = $(or $(firstword $(shell which nodejs node)),$(error "node not in path!"))


# JSEnv: mixin that describes the environment for running Node
#
JSEnv.inherit = _JSEnv BuildJS
_JSEnv.exports = {inherit} NODE_PATH
_JSEnv.NODE_PATH = $(subst $(\s),:,{nodePathDirs})
_JSEnv.nodePathDirs = .

# JSBundle(JSSOURCE): bundle source & its dependencies into one source file
#
JSBundle.inherit = _JSBundle
_JSBundle.inherit = JSEnv Builder
_JSBundle.outExt = .js
_JSBundle.command = {exportPrefix} {jsdepExe} {flags} -o {@} -MF {depsMF} {<}
_JSBundle.up = {jsdepExe}
_JSBundle.flags = --bundle
_JSBundle.depsMF = {outBasis}.d


# JSToHTML(JSSOURCE): bundle source & its dependencies into an HTML file
#
JSToHTML.inherit = _JSToHTML
_JSToHTML.inherit = JSBundle
_JSToHTML.outExt = .html
_JSToHTML.flags = --html


# JSTest(TEST): Execute JavaScript source file TEST.
#
#    Other JS sources loaded by TEST will be identified, and if there are
#    tests for those tests will be marked as strict dependencies so that
#    those tests will be executed before this test.  Testing sources are
#    identified using the {getTest_fn} function.
#
JSTest.inherit = _JSTest
_JSTest.inherit = JSEnv Test
_JSTest.exec = {node} {execArgs} {^}
_JSTest.deps = JSScan($(word 1,{inIDs}))


# JSScan(TEST): generate *and include* a makefile declaring the implicit
#    dependencies of JavaScript file TEST, including order-only dependencies
#    for tests of dependencies.
#
#    Why do we use a separate Minion instance (Make rule) to generate
#    dependencies?  Unlike CC and other cases, where the .d file is
#    generated by the same rule that generates the file it describes?  This
#    is because of test ordering.  We want to run lower-level tests before
#    higher-level ones, and so we need the order-only dependencies *before*
#    running the tests.  Having a separate rule that names the included
#    makfile as a target triggers Make's auto-restart feature.
#
#    Note that this will not create rules for lower-level tests; it will
#    only establish ordering for tests that are otherwise named as targets.
#
JSScan.inherit = _JSScan
_JSScan.inherit = JSEnv Builder
_JSScan.outExt = .d
# We omit the source file from {in} in order to avoid tooltree/build/makebug.mk;
# -MTF will emit it as a dependency along with others
_JSScan.in =
_JSScan.hidden< = $(call get,out,$(_arg1))
_JSScan.command = {exportPrefix} {jsdepExe} {hidden<} -MF {@} -Moo {Moo} -MT {MT} -MTF
_JSBundle.up = {jsdepExe}
_JSScan.MT = $(call get,out,JSTest($(_argText)))
_JSScan.Moo = $(call get,out,JSTest(^B_q.js))
_JSScan.rule = {inherit}-include {@}$(\n)

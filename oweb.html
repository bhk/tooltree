<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<style type="text/css">
/* Smark-specific classes */

.super {
  vertical-align: super;
  font-size: 0.7em;
}

.smarkdoc {
  font-family: "Segoe UI", Geneva, Helvetica, Arial, sans-serif;
  font-size: 14px;
  margin: 2em;
}

.indent {
    margin: 0 3em;
}

.xh { display: none; }

/*
|| Floats affect text flow but not block boundaries, so graphics in a DIV
|| would overlap floats if not for "clear: both"
*/
.diagram {
  margin: 18px 0;
  clear: both;
}

/* ========  .art  ======== */
/* wheat-toned color scheme */

.art {
  margin-right: auto; margin-left: auto; /* center */
  font-family: Arial, Verdana, "Lucida Console", Monaco, monospace;
  font-weight: bold;
}
.art * {
  border-color: #56573A;
}
.art .dline, .art .drect {
  border-style: dotted;
}
.art .rect {
  box-shadow: 2px 2px 3px rgba(0,0,0,0.3);
  -moz-box-shadow: 2px 2px 3px rgba(0,0,0,0.3);
  background-color:  #f6f4ea; /*#f9faf4; #fafff4; #f8f8ec;  */
  border-radius: 3px;
  -moz-border-radius: 3px;
}
.art .nofx {
   background-color:  #f9faf4;
}
.art .round {
   border-radius:         0.7em;
   -webkit-border-radius: 0.7em;
   -moz-border-radius:    0.7em;
}

.msc {
   font: 11px Verdana, Monaco, "Lucida Console";
   margin-left: auto; margin-right: auto;
   background-color: white;
}

.tocLevel { margin-left: 2em; font-weight: normal; }
.tocLevel .tocLevel { font-size: 0.9em; }
.toc>.tocLevel { font-weight: bold; margin: 0.5em 0 }
.toc {
    column-count: 2; column-gap: 2em;
    -moz-column-count: 2; -moz-column-gap: 2em;
    -webkit-column-count: 2; -webkit-column-gap: 2em;
}

/* General apperance settings */

a {
    text-decoration: none;
}

h1, h2, h3 { color: #339; }

h1 {
    text-align: center;
    font-size: 200%;
    clear: both;
    margin: 2em 0;
}
h2 {
    font-size: 160%;
    padding-bottom: 2px;
    border-bottom: 2px solid #338;
    clear: both;
    margin: 2em 0 1.5em;
}
h3 {
    font-size: 135%;
    clear: both;
    margin: 2em 0 1em;
}
h4 {
    font-size: 120%;
    margin: 2em 0 1em;
}

.pre, code {
  font-family: "Lucida Console", "Monaco", "Courier New", monospace;
  background-color: #f7f7f7;
}

code {
  padding: 1px 1px 0 1px;
  border: 1px solid #e4e4e4;
  border-radius: 2px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
}

pre {
  font-family: "Lucida Console", "Monaco", "Courier New", monospace;
  background-color: #f0f0f0;
  color: #114;
  padding: 2px 3px;
  border: 1px solid #e4e4e4;
  border-radius: 2px;
  -webkit-border-radius: 2px;
  -moz-border-radius: 2px;
  margin: 0.5em 2em;
}

table {
   border-collapse: collapse;
   border-width: 1px;
   border-spacing: 1px;
   border-color: transparent;
   margin: 16px 0;
   width: 100%;
}
th {
   background-color: #eee; color: black;
}
td, th {
   border-style: solid;
   border-color: #bbb;
   border-width: 1px;
   padding: 0 6px;
}
td p:first-child, th p:first-child {
   margin-top: 3px;
}
td p:last-child, th p:last-child {
   margin-bottom: 3px;
}

.indent {
    margin-top: 2em;
    margin-bottom: 2em;
}


@media print {

  @page {
    margin: 0.75in 0.75in;
    size: Letter;
    @bottom {
      content: counter(page);
      vertical-align: top;
      padding-top: 1em;
    }
  }
  h1 { text-align: center;
       margin: 0.75in 0 0.75in; }
  h2 { string-set: section content() }
  .toc { margin: 3em -2em }
  .toc a::after {
     font-size: 10px;
     content: leader(' . ') "  " target-counter(attr(href), page);
  }
  table { page-break-inside: avoid; }
}

</style><title>OWeb: Observable Web</title>
</head><body>
<div class="smarkdoc"><h1>
<a name="OWeb:%20Observable%20Web"></a>OWeb: Observable Web
</h1><p>
This library allows for JavaScript running in a browser to observe state changes on a web server.
</p><h2>
<a name="Usage"></a>Usage
</h2><p>
First we require the appropriate modules and create an <code>OWeb</code> instance with the appropriate URI for the server's OWeb app.
</p><pre>var OWeb = require('oweb.js');
var xhttp = require('xhttp.js');
var oweb = OWeb.create(xhttp, "/observe/path");
</pre><p>
To create a <code>WebVar</code> instance, we specify an <b>entity name</b>, which identifies what server state we are watching. This can be any string.
</p><pre>var webVar = oweb.observe('entityName');
</pre><p>
<code>webVar.getValue()</code> will return <code>undefined</code> until a value has been successfully retrieved.
</p><p>
No network request will be made, however, until something subscribes to <code>webVar</code>. At that point, any changes on the server side will update <code>webVar</code> and trigger notifications to its subscribers. For example, the following code will begin monitoring the value over the network and write every new value to the console, given an instance, <code>a</code>, of <code>Activator</code> (see <a href="observables.html">Observables</a>):
</p><pre>dereg = a.activate(console.log.bind(console), webVar)};
</pre><p>
When the last subscribed unsubscribes to <code>webVar</code>, network requests will cease. For example, this will stop the monitoring:
</p><pre>dereg();
</pre><p>
Errors are indicated by an object value whose <code>type</code> property is <code>error</code>. The <code>text</code> property may contain a human-readable description.
</p><h2>
<a name="Protocol"></a>Protocol
</h2><p>
The protocol is based on HTTP long-polling: the server may delay its response until certain condition is met, as when an observed value changes. When a response is being delayed, we say the transaction is &#8220;pending&#8221;. Many servers and browsers enforce no time limits on connections, but proxies might.
</p><p>
A single request can watch multiple entities. A response is sent when there is data for any of the watched entities, and a response may include multiple entities.
</p><p>
OWeb requests use the HTTP method <code>POLL</code>.
</p><p>
The request URI identifies the server-side endpoint. One web server could host different OWeb POLL URIs that operate entirely independently. In this document, the term &#8220;server&#8221; when unqualified refers to the server-side OWeb endpoint, which will typically be embodied in a Web server application, not a web server or host machine.
</p><p>
Requests and responses are JSON-encoded data structures. Entity names are JSON strings, and entity values are arbitrary JSON values.
</p><pre>Request = {
   id: Value,            // optional
   add: [Name, ...],     // optional
   remove: [Name, ...]   // optional
}

Response = {
   id: Value,            // optional
   values: { Name: Value, ... }
}

Name = String
Value = &lt;any JSON value&gt;
</pre><h3>
<a name="IDs"></a>IDs
</h3><p>
When a request incldues an <code>id</code> values, it is a &#8220;successor&#8221; transaction. The ID must match the ID of a previous response, its &#8220;predecessor&#8221;. In this case, the set of entities being observed by a transaction is the set observed by its predecessor, minus any names in <code>remove</code>, plus any names in <code>add</code>.
</p><p>
When the request does not contain an ID, the transaction observes only the entities named in <code>add</code>.
</p><p>
An entity is considered &#8220;ready&#8221; when its value has changed since the predecessor, or if it has been added in that request. The request remains pending until at least one entity is ready.
</p><p>
Any removals are processed before any additions, so an entity named in both sets will be observed by the new transaction, <i>and</i> will be immediately sent in the response.
</p><p>
When the set observed by a transaction is empty, the transaction responds immediately, with no <code>id</code> field. This will happen when an initial request specifies no names to add, or when a non-initial request removes all of the previously subscribed names.
</p><h3>
<a name="Ordering%20Constraints"></a>Ordering Constraints
</h3><p>
The client acknowledges a transaction by making another request that names it as a predecessor.
</p><p>
When a transaction is acknowledged, the server discards transactions that precede it. Once a transaction is discarded, it cannot be named as a predecessor by future transactions.
</p><p>
For each completed transaction, there can be only one pending transaction that names it as a predecessor. If request B arrives while request A is still pending (A and B naming the same predecessor), request A will return an error result.
</p><p>
For each completed transaction, there can be only one valid successor. If request B arrives after the server has responded to request A has completed (A and B having the same predecessor), the server will discard transaction A.
</p><p>
The above rules are intended to support the following use model:
</p><ul>
<li>
<p>
Nominally, the client issues a series of transactions, each one referring to the previous as its predecessor.
</p>
</li><li>
<p>
If a transaction fails, the client may automatically issue a new request, which might differ from the previous request (since the client's set of entities may have changed). Note that when the client detects failure it cannot distinguish between the following server-side conditions:
</p><ul type="circle">
<li>
<p>
The request was never seen.
</p>
</li><li>
<p>
The request was in, or remains in, a pending state.
</p>
</li><li>
<p>
A response was sent.
</p>
</li>
</ul>
</li>
</ul><h3>
<a name="Timeouts"></a>Timeouts
</h3><p>
Transactions may be discarded by the server when the remain unused for some amount of time. A transaction is &#8220;used&#8221; when there is no transaction being handled or pending that names it as a predecessor.
</p><h3>
<a name="Errors"></a>Errors
</h3><p>
In the event of an error processing the request, an HTTP error response will be returned.
</p><ul>
<li>
<p>
400 = error in JSON parsing of the request
</p>
</li><li>
<p>
409 = request was pre-empted by another request naming the same preecessor
</p>
</li><li>
<p>
410 = invalid predecessor ID specified
</p>
</li>
</ul><p>
Item-specific errors &#8212; such as &#8220;unknown entity&#8221; &#8212; are indicated by object values with an <code>error</code> field. These are returned by the server just as any observed JSON value is returned.
</p><pre>{ error: String }
</pre><ul>
<li>
<p>
<code>"unk"</code> = not found (entity does not exist)
</p>
</li>
</ul><h2>
<a name="Multiplexing"></a>Multiplexing
</h2><p>
Each <code>OWeb</code> instance multiplexes all of its observation requests into a single HTTP transaction at a time. When an observed entity becomes subscribed to, or becomes unsubscribed, any pending transaction is cancelled and a new one is launched.
</p></div>
</body>
</html>

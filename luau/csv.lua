-- CSV: read/write Comma-Separated Value files
--
-- This module defines and supports a file format for tabular data that
-- allows metadata such as column names to be included, while maximizing
-- compatibility with existing software packages that claim to support "CSV"
-- formats.  This format uses only ASCII text characters for delimiters and
-- escape characters, but it can be used to store binary data.  When table
-- cell contents are all ASCII, the resulting CSV file will contain only
-- ASCII characters.
--
-- Metadata is contained in lines that begin with a "#" character at the
-- start of the file.  Afer the first non-metadata line, a line with an
-- initial "#" will be treated as ordinary data.
--
-- The following formats for metadata lines are supported:
--
--   #csv a,b,...       Specifies column names.
--
--   #set name=value    Gives a name and value to be added to each row as if
--                      'name' were in '#csv' and 'value' appeared on every line.
--
--   # ...text...       Ignored; intended for human-readable comments.  A space
--                      after the "#" ensures that the line will not conflict
--                      with future extensions to the syntax.
--
-- Column names specified after #csv and the 'value' part of #set are
-- encoded just as table rows are encoded, except that they may not
-- contain line breaks.
--
-- Table data follows the metadata lines.  Each row is terminated with a
-- newline (ASCII 10) character, optionally preceded by a carriage return
-- (ASCII 13) character.  Values within a row are separated by commas.
--
-- Values may not contain commas or newlines unless the value is surrounded
-- by double-quote (ASCII 34) characters.  Inside a quoted value, any
-- embedded double-quote character is represented by two consecutive
-- double-quote characters.
--
-- API
--
-- csv.decode(text, [columns])
--
--   Returns a table that contains an array of rows and a member called
--   'info' that contains any metainformation.
--
--   When column names are not known, numeric indices (1-based) are used,
--   making each row an array.
--
--   For each column whose name is known, the name will be used as a key
--   instead of the numeric index.  Column names can be assigned by a "#csv"
--   metadata line within the file, or when that is absent, by the value of
--   the optional 'columns' argument.  The 'columns' argument is a string
--   containing a comma-delimited list of column names.
--
--   Each metadata line matching "#<name> <value>" is stored in the info
--   table, which contains an array describing the metadata lines, in order,
--   and also maps each <name> to its <value>:
--
--     #info     -> number of metadata lines
--     info[ndx] ->  {name=<string>, value=<string>}
--     info.<name>  = last value associated with property named <name>
--
--   Examples:
--
--       csv.decode("x,y")           ->  {{"x","y"},info={}}
--       csv.decode("x\ny")          ->  {{"x"},{"y"},info={}}
--       csv.decode("x,y", "a,b")    ->  {{a="x",b="y"},info={}}
--       csv.decode("#csv a,b\nx,y") ->  {{a="x",b="y"},info=...}
--
--   In the last example, info = { {name="csv",value="a,b"}, csv="a,b"}.
--
-- csv.loadFile(fname, [columns])
--
--   Read CSV file from file named 'fname' and decode it.  The result is
--   as described for 'decode'.
--
-- csv.encode(tbl, columns)
--
--   Construct a CSV file.  The file will have one row per array element in
--   tbl[].
--
--   The 'columns' argument (same format as in csv.decode) specifies
--   the number of columns and their order, in one of three ways depending
--   on the type of value passed:
--
--     number : the value gives the number of columns, which are indexed with
--              positive integers.
--
--     table : the value is an array of column names to be output.  When
--             columns.csv is true, the output will include a "#csv"
--             metadata line describing the column names.
--
--     string : the value is a CSV row containing the names of columns to be
--              output.  The resulting CSV file will contain a "#csv"
--              metadata line containing these column names.
--
--              The value "a,b" is equivalent to  {"a","b",csv=true}.
--
--
--   Values not present in 'tbl' will quietly generate empty strings.
--
--   Encode() does not recognize the 'info' field generated by decode().
--
--   Examples:
--
--       csv.encode({{"x","y"}}, 2)          ->  "x,y\n"
--       csv.encode({{"x"},{"y"}}, 1)        ->  "x\ny\n"
--       csv.encode({{a="x",b="y"}}, "a,b")  ->  "#csv a,b\nx,y\n"
--

local csv = {}

-- readValue(text,pos) -> str, sep, posx
--   str = decoded value
--   sep = character(s) terminating the value: COMMA, LF, or empty string
--   posx = position in text following the separator
--
local function readValue(text, pos)
   local qstr = ""   -- quoted string may be followed by unquoted text

   if text:find('^"', pos) then
      -- Quoted string
      local i, c
      i = pos+1
      repeat
         -- find closing quote
         c, i = text:match('"("?)()', i)
      until c ~= '"'
      local strEnd = i and i-2 or #text
      qstr = text:sub(pos+1, strEnd):gsub('""', '"')
      pos = i or #text+1
   end

   -- Unquoted string: look for next COMMA or LF
   local v, sep, posx = text:match("([^,\r\n]*)\r*([,\n]?)()", pos)
   return qstr..v, sep, posx
end

-- readRow(text, pos)  ->  table, posx
--
--    readRow() will return an array with at least one member.
--
local function readRow(text, pos)
   local t = {}
   local v,sep

   repeat
      v,sep,pos = readValue(text, pos)
      table.insert(t, v)
   until sep ~= ","
   return t, pos
end

function csv.decode(text, columns)
   local info = {}
   local tbl = { info = info }
   local pos = 1

   -- read metadata
   while true do
      local mstr, posx = text:match("^#([^\n]*)\n?()", pos)
      if not mstr then break end
      pos = posx
      local pname,pvalue = mstr:match("^(%w+)%s+(.-)\r*$")
      if pname then
         table.insert(info, {name=pname, value=pvalue})
         info[pname] = pvalue
      end
   end

   -- read values
   while pos <= #text do
      local values
      values, pos = readRow(text, pos)
      table.insert(tbl, values)
   end

   csv.useKeyNames(tbl, columns)

   return tbl
end

-- Convert rows from array form to name->value form
--
function csv.useKeyNames(tbl, columns)

   -- "#csv <column names>"
   local keys = tbl.info.csv or columns
   if keys then
      keys = readRow(keys, 1)
      for _,row in ipairs(tbl) do
         for ndx,v in ipairs(row) do
            local colname = keys[ndx]
            if colname then
               row[colname] = v
               row[ndx] = nil
            end
         end
      end
   end

   -- "#set <name>=<value>"
   for _,m in ipairs(tbl.info) do
      if m.name == "set" then
         local name,value = m.value:match("([^=]*)=(.*)")
         value = readValue(value, 1)
         if name then
            for _,row in ipairs(tbl) do
               row[name] = value
            end
         end
      end
   end
end

function csv.loadFile(file, columns)
   local f, err = io.open(file, 'rb')
   if not f then
      return f, err
   end

   local text = f:read("*a")
   f:close()
   return csv.decode(text, columns)
end

local function quoteValue(v)
   v = (v==nil) and "" or tostring(v)
   if v:match("^[#%s]") or v:match('[,"\n\r]') or v:match("%s$") then
      v = '"' .. v:gsub('"', '""') .. '"'
   end
   return v
end

-- Convert table to CSV file; return result as a single string
--
function csv.encode(tbl, columns)
   local out = {}
   local cols = {}

   if type(columns) == "number" then
      for ndx = 1, columns do
         cols[ndx] = ndx
      end
   elseif type(columns) == "string" then
      cols = readRow(columns, 1)
      cols.csv = true
   elseif type(columns) == "table" then
      cols = columns
   else
      error("csv.encode: Invalid type for 'columns'")
   end

   if cols.csv then
      local line = {}
      for ndx,v in ipairs(cols) do
         line[ndx] = quoteValue(v)
      end
      table.insert(out,  "#csv " .. table.concat(line, ","))
   end

   for _,row in ipairs(tbl) do
      local line = {}
      for _,fld in ipairs(cols) do
         table.insert(line, quoteValue( row[fld] ) )
      end
      table.insert(out, table.concat(line, ","))
   end
   table.insert(out, "")

   return table.concat(out, "\n")
end

-- Write CSV to opened file 'f'
--
function csv.writeFile(f, tbl, columns)
   f:write(csv.encode(tbl, columns))
   return true
end

return csv

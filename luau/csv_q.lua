local qt = require "qtest"
local csv = require "csv"

local T = qt.tests
local eq = qt.eq

local function tokenizeTable(t)
   local res = {}
   for _,row in ipairs(t) do
      table.insert(res, table.concat(row, ":"))
   end
   return table.concat(res, "|")
end

function T.decode()
   local function e(o,i)
      local t = csv.decode(i)
      t.info = nil   -- not interested in that in this test
      return eq(o, t)
   end

   e({},                 '')
   e({{""}},             '\n')
   e({{"a"},{"b","c"}},  'a\nb,c\n')
end

function T.decodeValues()
   local function e(o, i)
      local t = csv.decode(i)
      return eq(o, tokenizeTable(t))
   end

   e( "a:b",      'a,b' )          -- unquoted
   e( "a:b",      'a,b\n' )
   e( ":b",       ',b\n' )
   e( "a:",       'a,\n' )

   e( "a:",       '"a",""' )      -- quoted
   e( ":b",       '"","b"\n' )
   e( "a:b|c:d",  'a,b\nc,d\n' )   -- two records

   e( "a,b:c",    '"a,b",c')       -- quoted comma
   e( "a\nx:b",   '"a\nx",b')      -- quoted LF
   e( "a\r\nx:b", '"a\r\nx",b')    -- quoted CRLF
   e( 'a"b:c',     '"a""b",c' )    -- quoted QUOTE

   -- compatibility requirements
   --
   -- Decode Excel-encoded CSVs
   --  * Excel saves leading, trailing, and embedded spaces WITHOUT quoting.
   --    => preserve leading/trailing spaces
   --  * Excel quotes entire value when it contains any COMMA, QUOTE, or LF,
   --    with no trailing whitespace.
   --  * Excel does not seem to allow control characters other than LF.
   --
   -- Decode other forms (not generated by Excel) as Excel does:
   --  * Before quote:    [a"b,c]     ->  [a"b] [c]
   --  * Before quote:    [ "a",b]    ->  [ "a"] [b]
   --  * Internal quote:  [a","b,...] ->  [a"] [b,...]   (no special case)
   --  * Unterminated:    [a,"b]      ->  [a] [b]
   --  * After quotes:    ["a"b,"c"d] ->  [ab] [cd]
   --  * After quotes:    ["a" ,"c"d] ->  [a ] [cd]
   --  * After quotes:    ["a"b"c"d] ->   [ab"c"d]

   e( 'a"b:c',      'a"b,c' )          -- char before quote => unquoted
   e( ' "a":b',     ' "a",b' )         -- leading space => unquoted
   e( 'a:b',        'a,"b' )           -- unterminated
   e( 'a":b,',      'a","b,' )         -- no special case for ","
   e( 'ab:cd',      '"a"b,"c"d' )      -- text after quoted string
   e( 'a :c ',      '"a" ,"c" ' )      -- spaces after quoted string
   e( 'ab"c"d',     '"a"b"c"d' )       -- text + more quotes after quotes

   -- Special cases involving control chars

   e( 'a:b|#c:d',  'a,b\n#c,d\n')   -- '#' after a data line
   e( "a\rz:b",    '"a\rz",b\n' )   -- CR in quoted value
   e( "a:b",       'a,b\r\n' )      -- CRLF ending
   e( "a:b",       'a,b\r\r\n' )    -- CRCRLF ending
end

function T.decodeInfo()
   local vec = {
      "#csv a,b,c",
      "#csv a,b,c\r",
      "#csv a,b,c\r\n",
      "#csv a,b,c\n",
      "#csv a,b,c\n# comment",
      "# comment\r\n#csv a,b,c\n",
      "#csv a,b,c\n#set a=b",
      "#csv a,b,c\n#set a=b\r\n",
   }

   for _,text in ipairs(vec) do
      local t = csv.decode(text)
      eq("a,b,c", t.info.csv)
      eq(0, #t)
   end

   local t = csv.decode("")
   eq(0, #t)

   local t = csv.decode("\n")
   eq(1, #t)

   local t = csv.decode("#csv a,b\n\n")
   eq(1, #t)
end

function T.decodeNames()
   local str =
      '# This is a comment\n' ..
      '#csv a,b,c\n' ..
      '1,2,3\n' ..
      '"""4""","5,","6"\n' ..
      '"x\n' ..
      'y",b,c'

   -- "#csv ..."

   local t,w = csv.decode(str)
   eq(3, #t)
   eq({a="1",b="2",c="3"}, t[1] )
   eq({a="1",b="2",c="3"}, t[1] )
   eq({a='"4"',b="5,",c="6"}, t[2] )
   eq({a="x\ny",b="b",c="c"}, t[3] )

   -- "#set ..."

   t,w = csv.decode("#csv a\r\n#set b=x\r\n1\n2\n")
   eq(2, #t)
   eq({a="1",b="x"}, t[1] )
   eq({a="2",b="x"}, t[2] )

   t,w = csv.decode('#csv a\n#set b="x,y"\n1\n')
   eq(1, #t)
   eq({a="1",b="x,y"}, t[1])

end

function T.decodeBroken()
   local str =
      '#csv a,b\n' ..
      'x,y,z\n'

   local t = csv.decode(str)
   eq({a="x",b="y",[3]="z"}, t[1])
   eq( nil, t[2] )
end

function T.encode()
   local t = {
      { a=1, b='"', c=',' },     -- comma and quote in values
      { a='#4', x=5, c='"' },    -- "#" at beginning of row
   }

   local str = csv.encode(t, "a,b,c")

   -- examples from docs
   eq("x,y\n", csv.encode({{"x","y"}}, 2) )
   eq("x\ny\n", csv.encode({{"x"},{"y"}}, 1) )
   eq("#csv a,b\nx,y\n", csv.encode({{a="x",b="y"}}, "a,b") )

   -- table values for 'columns'
   eq("#csv a,b\nx,y\n", csv.encode({{a="x",b="y"}}, {"a","b",csv=true}) )
   eq("x,y\n", csv.encode({{a="x",b="y"}}, {"a","b"}) )

   -- quote COMMA, QUOTE, and leading "#"
   eq('#csv a,b,c\n1,"""",","\n"#4",,""""\n', str)

   -- quote CR or LF
   eq('#csv a\n"a\nx"\n"b\ry"\n', csv.encode( {{a="a\nx"},{a="b\ry"}}, "a"))

   -- quote value with leading or trailing spaces
   eq('#csv a\n" x"\n"y "\n', csv.encode( {{a=" x"},{a="y "}}, "a"))


end

return qt.runTests()
